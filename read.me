Аналіз відповідності принципам SOLID

S: Single Responsibility Principle (Принцип єдиної відповідальності)
    Кожен клас у цьому коді має чітко визначену відповідальність:
        DatabaseAbstract і Database: Відповідають за підключення до бази даних та завантаження даних.
        SoupFetcher: Відповідає за отримання HTML-коду сторінок.
        JsonFileHandlerAbstract і JsonFileHandler: Відповідають за зчитування та запис даних у JSON файли.
        Scraper: Абстрактний клас, який визначає інтерфейс для класів скрапінгу.
        AuthorScraper: Відповідає за скрапінг даних про авторів.
        QuoteScraper: Відповідає за скрапінг цитат.
        ScraperAbstract і ScraperManager: Відповідають за управління процесом скрапінгу та зберігання даних.
        Таким чином, код відповідає принципу єдиної відповідальності.

O: Open/Closed Principle (Принцип відкритості/закритості)
    Код відкритий для розширення, але закритий для модифікації:
        Абстрактні класи (DatabaseAbstract, JsonFileHandlerAbstract, Scraper, ScraperAbstract) дозволяють розширювати функціонал без зміни існуючого коду. 
        Наприклад, можна додати нові методи скрапінгу, створивши новий клас, який успадковує Scraper.
        Конкретні реалізації (Database, JsonFileHandler, AuthorScraper, QuoteScraper) можуть бути замінені новими реалізаціями, не змінюючи існуючий код.

L: Liskov Substitution Principle (Принцип підстановки Лісков)
    Класи-нащадки повинні коректно працювати замість базових класів:
        Класи Database, JsonFileHandler, AuthorScraper, QuoteScraper, і ScraperManager є конкретними реалізаціями абстрактних класів, 
        і вони можуть бути використані там, де очікуються їх базові класи (DatabaseAbstract, JsonFileHandlerAbstract, Scraper, ScraperAbstract).

I: Interface Segregation Principle (Принцип розділення інтерфейсів)
    Цей принцип означає, що клієнти не повинні залежати від інтерфейсів, які вони не використовують. У цьому коді:
        Абстрактні класи (DatabaseAbstract, JsonFileHandlerAbstract, Scraper, ScraperAbstract) визначають мінімально необхідні методи, 
        які потрібні для конкретної функціональності.
        Кожен клас реалізує лише ті методи, які необхідні для його функціонування, що відповідає принципу розділення інтерфейсів.

D: Dependency Inversion Principle (Принцип інверсії залежностей)
    Високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва повинні залежати від абстракцій:
        В коді використовуються абстрактні класи для визначення інтерфейсів (DatabaseAbstract, JsonFileHandlerAbstract, Scraper, ScraperAbstract).
        Реалізації високорівневих класів (ScraperManager) залежать від абстракцій (інтерфейсів), а не від конкретних реалізацій.


Висновок
Загалом, код добре відповідає принципам SOLID:
    Принцип єдиної відповідальності: Кожен клас має чітко визначену відповідальність.
    Принцип відкритості/закритості: Код легко розширюється без модифікації існуючого коду.
    Принцип підстановки Лісков: Класи-нащадки коректно працюють замість базових класів.
    Принцип розділення інтерфейсів: Інтерфейси розділені відповідно до потреб клієнтів.
    Принцип інверсії залежностей: Високорівневі модулі залежать від абстракцій, а не від конкретних реалізацій.
    Таким чином, цей код є прикладом гарної практики об'єктно-орієнтованого дизайну відповідно до принципів SOLID.





